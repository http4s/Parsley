package parsley

import parsley.ExpressionParser._
import parsley.Combinator._

/** This class is used to generate efficient expression parsers given a table of operators
  * in operator of operator precedence and an atomic value that represents the smallest
  * part of the expression. Caters to unary and binary operators of different associativities.
  * @param table A table of operators. Table is ordered highest precedence to lowest precedence.
  *              Each list in the table corresponds to operators of the same precedence level.
  * @param atom The smallest unchainable unit of the expression, for instance numbers/variables
  */
class ExpressionParser[Tok, A](atom: =>Parsley[Tok, A], table: OpList[Tok, A]*)
{
    private def convertOperator(opList: OpList[Tok, A]): Parsley[Tok, A] => Parsley[Tok, A] = opList match
    {
        case Infixes(assoc, ops @ _*) => assoc match
        {
            case AssocLeft => chainl1(_, choice(ops: _*))
            case AssocRight => chainr1(_, choice(ops: _*))
        }
        case Prefixes(ops @ _*) => chainPre(_, choice(ops: _*))
        // FIXME: Postfix operators which are similar to binary ops may fail, how can we work around this?
        case Postfixes(ops @ _*) => chainPost(_, choice(ops: _*))
    }

    /** The expression parser generated by this generator. */
    lazy val expr: Parsley[Tok, A] = table.map(convertOperator).foldLeft(atom)((p, op) => op(+p))
}

object ExpressionParser
{

    /** Denotes the associativity of an operator, either `AssocLeft` or `AssocRight`. */
    sealed trait Assoc
    case object AssocLeft extends Assoc
    case object AssocRight extends Assoc

    /** A list of operators on the same precedence level. Note operators of different fixities cannot
      * mix on the same level of indentation. Either `Infixes` which is a list of infix binary operators,
      * `Prefixes` which is a list of prefixing unary operators or `Postfixes` a list of postfixing unary
      * operators.
      * @tparam A The result type of the operation
      */
    sealed trait OpList[Tok, +A]
    case class Infixes[Tok, A](assoc: Assoc, op: Parsley[Tok, (A, A) => A]*) extends OpList[Tok, A]
    case class Prefixes[Tok, A](op: Parsley[Tok, A => A]*) extends OpList[Tok, A]
    case class Postfixes[Tok, A](op: Parsley[Tok, A => A]*) extends OpList[Tok, A]
}