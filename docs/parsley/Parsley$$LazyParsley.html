<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Parsley documentation  - parsley.Parsley.LazyParsley</title><meta content="Parsley documentation - parsley.Parsley.LazyParsley" name="description"/><meta content="Parsley documentation parsley.Parsley.LazyParsley" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript" src="../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title">Parsley documentation<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.parsley" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parsley"></a><a id="parsley:parsley"></a> <span class="permalink"><a href="index.html#parsley" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">parsley</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="parsley.Parsley" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Parsley"></a><a id="Parsley:Parsley"></a> <span class="permalink"><a href="../parsley/index.html#Parsley" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Parsley$.html" title=""><span class="name">Parsley</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="parsley" id="parsley" class="extype">parsley</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="Parsley$$LazyChooseParsley.html" title="" class="class"></a><a href="Parsley$$LazyChooseParsley.html" title="">LazyChooseParsley</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Parsley$$LazyMapParsley.html" title="" class="class"></a><a href="Parsley$$LazyMapParsley.html" title="">LazyMapParsley</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="" title="" class="class"></a><a href="" title="">LazyParsley</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="index.html" name="parsley" id="parsley" class="extype">parsley</a>.<a href="Parsley$.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a></p><h1>LazyParsley<span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">implicit final </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">LazyParsley</span><span class="tparams">[<span name="P">P</span>, <span name="A">+A</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="parsley.Parsley.LazyParsley"><span>LazyParsley</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;init&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(p:=&gt;P)(implicitcon:P=&gt;parsley.Parsley[A]):parsley.Parsley.LazyParsley[P,A]"></a><a id="&lt;init&gt;:LazyParsley[P,A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;init&gt;(p:=&gt;P)(implicitcon:P=&gt;parsley.Parsley[A]):parsley.Parsley.LazyParsley[P,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">LazyParsley</span><span class="params">(<span name="p">p: =&gt; <span name="parsley.Parsley.LazyParsley.P" class="extype">P</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="con">con: (<span name="parsley.Parsley.LazyParsley.P" class="extype">P</span>) =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span>)</span></span></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="parsley.Parsley.LazyParsley#!" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!(msggen:A=&gt;String):parsley.Parsley[Nothing]"></a><a id="!((A)=&gt;String):Parsley[Nothing]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#!(msggen:A=&gt;String):parsley.Parsley[Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang">!</span><span class="params">(<span name="msggen">msggen: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Nothing" class="extype">Nothing</span>]</span></span><p class="shortcomment cmt">Same as <code>fail</code>, except allows for a message generated from the result of the failed parser.</p><div class="fullcomment"><div class="comment cmt"><p>Same as <code>fail</code>, except allows for a message generated from the result of the failed parser. In essence, this
is equivalent to <code>p &gt;&gt;= (x =&gt; fail(msggen(x))</code> but requires no expensive computations from the use of <code>&gt;&gt;=</code>.</p></div><dl class="paramcmts block"><dt class="param">msggen</dt><dd class="cmt"><p>The generator function for error message, creating a message based on the result of invokee</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that fails if it succeeds, with the given generator used to produce the error message</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley##&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="#&gt;[B](x:B):parsley.Parsley[B]"></a><a id="#&gt;[B](B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html##&gt;[B](x:B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$greater">#&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="x">x: <span name="parsley.Parsley.LazyParsley.#&gt;.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.#&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This is the parser that corresponds to <code>p *&gt; pure(x)</code> or a more optimal version of <code>p.map(_ =&gt; x)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This is the parser that corresponds to <code>p *&gt; pure(x)</code> or a more optimal version of <code>p.map(_ =&gt; x)</code>.
It performs the parse action of the invokee but discards its result and then results the value <code>x</code> instead</p></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>The value to be returned after the execution of the invokee</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser which first parses the invokee, then results <code>x</code></p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#*&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="*&gt;[A_&gt;:A,B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="*&gt;[A_&gt;:A,B](=&gt;Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#*&gt;[A_&gt;:A,B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $times$greater">*&gt;</span><span class="tparams">[<span name="A_">A_ &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="q">q: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.*&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.*&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This is the parser that corresponds to a more optimal version of <code>p.map(_ =&gt; x =&gt; x) &lt;*&gt; q</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This is the parser that corresponds to a more optimal version of <code>p.map(_ =&gt; x =&gt; x) &lt;*&gt; q</code>. It performs
the parse action of both parsers, in order, but discards the result of the invokee.</p></div><dl class="paramcmts block"><dt class="param">q</dt><dd class="cmt"><p>The parser whose result should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser which first parses <code>p</code>, then <code>q</code> and returns the result of <code>q</code></p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;#&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;#&gt;[B](f:A=&gt;B):parsley.Parsley[B]"></a><a id="&lt;#&gt;[B]((A)=&gt;B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;#&gt;[B](f:A=&gt;B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$hash$greater">&lt;#&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="parsley.Parsley.LazyParsley.&lt;#&gt;.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;#&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>map</code></p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;*" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;*[B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[A]"></a><a id="&lt;*[B](=&gt;Parsley[B]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;*[B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$times">&lt;*</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="q">q: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;*.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">This is the parser that corresponds to a more optimal version of <code>p.map(x =&gt; _ =&gt; x) &lt;*&gt; q</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This is the parser that corresponds to a more optimal version of <code>p.map(x =&gt; _ =&gt; x) &lt;*&gt; q</code>. It performs
the parse action of both parsers, in order, but discards the result of the second parser.</p></div><dl class="paramcmts block"><dt class="param">q</dt><dd class="cmt"><p>The parser who should be executed but then discarded</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser which first parses <code>p</code>, then <code>q</code> and returns the result of the <code>p</code></p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;**&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;**&gt;[B](pf:=&gt;parsley.Parsley[A=&gt;B]):parsley.Parsley[B]"></a><a id="&lt;**&gt;[B](=&gt;Parsley[(A)=&gt;B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;**&gt;[B](pf:=&gt;parsley.Parsley[A=&gt;B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$times$times$greater">&lt;**&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[(<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="parsley.Parsley.LazyParsley.&lt;**&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;**&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is defined as <code>lift2((x, f) =&gt; f(x), p, f)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This combinator is defined as <code>lift2((x, f) =&gt; f(x), p, f)</code>. It is pure syntactic sugar.</p></div></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;*&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;*&gt;[B,C](px:=&gt;parsley.Parsley[B])(implicitev:P&lt;:&lt;parsley.Parsley[B=&gt;C]):parsley.Parsley[C]"></a><a id="&lt;*&gt;[B,C](=&gt;Parsley[B])(&lt;:&lt;[P,Parsley[(B)=&gt;C]]):Parsley[C]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;*&gt;[B,C](px:=&gt;parsley.Parsley[B])(implicitev:P&lt;:&lt;parsley.Parsley[B=&gt;C]):parsley.Parsley[C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$times$greater">&lt;*&gt;</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="px">px: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;*&gt;.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="parsley.Parsley.LazyParsley.P" class="extype">P</span>, <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[(<span name="parsley.Parsley.LazyParsley.&lt;*&gt;.B" class="extype">B</span>) =&gt; <span name="parsley.Parsley.LazyParsley.&lt;*&gt;.C" class="extype">C</span>]]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;*&gt;.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">This is the Applicative application parser.</p><div class="fullcomment"><div class="comment cmt"><p>This is the Applicative application parser. The type of <code>pf</code> is <code>Parsley[A =&gt; B]</code>. Then, given a
<code>Parsley[A]</code>, we can produce a <code>Parsley[B]</code> by parsing <code>pf</code> to retrieve <code>f: A =&gt; B</code>, then parse <code>px</code>
to receive <code>x: A</code> then return <code>f(x): B</code>.
</p></div><dl class="paramcmts block"><dt class="param">px</dt><dd class="cmt"><p>A parser of type A, where the invokee is A =&gt; B</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser which parses <code>pf</code>, then <code>px</code> then applies the value returned by <code>px</code> to the function
        returned by <code>pf</code></p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p><code>pure(f) &lt;*&gt; p</code> is subject to the same aggressive optimisations as <code>map</code>. When using impure functions
the optimiser may decide to cache the result of the function execution, be sure to use <code>unsafe</code> in order to
prevent these optimisations.</p></span></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;+:&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;+:&gt;[B&gt;:A](ps:=&gt;parsley.Parsley[Seq[B]]):parsley.Parsley[Seq[B]]"></a><a id="&lt;+:&gt;[B&gt;:A](=&gt;Parsley[Seq[B]]):Parsley[Seq[B]]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;+:&gt;[B&gt;:A](ps:=&gt;parsley.Parsley[Seq[B]]):parsley.Parsley[Seq[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$plus$colon$greater">&lt;+:&gt;</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="ps">ps: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="parsley.Parsley.LazyParsley.&lt;+:&gt;.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="parsley.Parsley.LazyParsley.&lt;+:&gt;.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">This parser corresponds to <code>lift2(_+:_, p, ps)</code>.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;/&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;/&gt;[B&gt;:A](x:B):parsley.Parsley[B]"></a><a id="&lt;/&gt;[B&gt;:A](B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;/&gt;[B&gt;:A](x:B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$div$greater">&lt;/&gt;</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="x">x: <span name="parsley.Parsley.LazyParsley.&lt;/&gt;.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;/&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is defined as <code>p &lt;|&gt; pure(x)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This combinator is defined as <code>p &lt;|&gt; pure(x)</code>. It is pure syntactic sugar.</p></div></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;::&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;::&gt;[B&gt;:A](ps:=&gt;parsley.Parsley[List[B]]):parsley.Parsley[List[B]]"></a><a id="&lt;::&gt;[B&gt;:A](=&gt;Parsley[List[B]]):Parsley[List[B]]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;::&gt;[B&gt;:A](ps:=&gt;parsley.Parsley[List[B]]):parsley.Parsley[List[B]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$colon$colon$greater">&lt;::&gt;</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="ps">ps: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.Parsley.LazyParsley.&lt;::&gt;.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.Parsley.LazyParsley.&lt;::&gt;.B" class="extype">B</span>]]</span></span><p class="shortcomment cmt">This parser corresponds to <code>lift2(_::_, p, ps)</code>.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;\&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;\&gt;[B&gt;:A](q:parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="&lt;\&gt;[B&gt;:A](Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;\&gt;[B&gt;:A](q:parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$bslash$greater">&lt;\&gt;</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="q">q: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;\&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;\&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is defined as <code>attempt(p) &lt;|&gt; q</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This combinator is defined as <code>attempt(p) &lt;|&gt; q</code>. It is pure syntactic sugar.</p></div></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;|&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;|&gt;[B&gt;:A](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="&lt;|&gt;[B&gt;:A](=&gt;Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;|&gt;[B&gt;:A](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$bar$greater">&lt;|&gt;</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="q">q: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;|&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;|&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This is the traditional Alternative choice operator for parsers.</p><div class="fullcomment"><div class="comment cmt"><p>This is the traditional Alternative choice operator for parsers. Following the parsec semantics precisely,
this combinator first tries to parse the invokee. If this is successful, no further action is taken. If the
invokee failed *without* consuming input, then <code>q</code> is parsed instead. If the invokee did parse input then the
whole parser fails. This is done to prevent space leaks and to give good error messages. If this behaviour
is not desired, use the <code>&lt;\&gt;</code> combinator (or <code>attempt(this) &lt;|&gt; q</code>) to parse <code>q</code> regardless of how the
invokee failed.</p></div><dl class="paramcmts block"><dt class="param">q</dt><dd class="cmt"><p>The parser to run if the invokee failed without consuming input</p></dd><dt>returns</dt><dd class="cmt"><p>The value produced by the invokee if it was successful, or if it failed without consuming input, the
        possible result of parsing q.</p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&lt;~&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;~&gt;[A_&gt;:A,B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[(A_,B)]"></a><a id="&lt;~&gt;[A_&gt;:A,B](=&gt;Parsley[B]):Parsley[(A_,B)]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&lt;~&gt;[A_&gt;:A,B](q:=&gt;parsley.Parsley[B]):parsley.Parsley[(A_,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$tilde$greater">&lt;~&gt;</span><span class="tparams">[<span name="A_">A_ &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="q">q: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&lt;~&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[(<span name="parsley.Parsley.LazyParsley.&lt;~&gt;.A_" class="extype">A_</span>, <span name="parsley.Parsley.LazyParsley.&lt;~&gt;.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">This parser corresponds to <code>lift2((_, _), p, q)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This parser corresponds to <code>lift2((_, _), p, q)</code>. For now it is sugar, but in future may be more optimal</p></div></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&gt;&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&gt;&gt;[B](q:parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="&gt;&gt;[B](Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&gt;&gt;[B](q:parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$greater">&gt;&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="q">q: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&gt;&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&gt;&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>*&gt;</code></p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&gt;&gt;=" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&gt;&gt;=[B](f:A=&gt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="&gt;&gt;=[B]((A)=&gt;Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&gt;&gt;=[B](f:A=&gt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$greater$eq">&gt;&gt;=</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&gt;&gt;=.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.&gt;&gt;=.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>flatMap</code></p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&gt;?&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&gt;?&gt;(pred:A=&gt;Boolean,msggen:A=&gt;String):parsley.Parsley[A]"></a><a id="&gt;?&gt;((A)=&gt;Boolean,(A)=&gt;String):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&gt;?&gt;(pred:A=&gt;Boolean,msggen:A=&gt;String):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$qmark$greater">&gt;?&gt;</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msggen">msggen: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for guard combinator, taking a dynamic message generator.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#&gt;?&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&gt;?&gt;(pred:A=&gt;Boolean,msg:String):parsley.Parsley[A]"></a><a id="&gt;?&gt;((A)=&gt;Boolean,String):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#&gt;?&gt;(pred:A=&gt;Boolean,msg:String):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$qmark$greater">&gt;?&gt;</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for guard combinator, taking a fixed message.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#?" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="?(msg:String):parsley.Parsley[A]"></a><a id="?(String):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#?(msg:String):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $qmark">?</span><span class="params">(<span name="msg">msg: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Sets the expected message for a parser.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expected message for a parser. If the parser fails then <code>expected msg</code> will added to the error</p></div></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#debug" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="debug[A_&gt;:A](name:String,break:parsley.Breakpoint):parsley.Parsley[A_]"></a><a id="debug[A_&gt;:A](String,Breakpoint):Parsley[A_]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#debug[A_&gt;:A](name:String,break:parsley.Breakpoint):parsley.Parsley[A_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">debug</span><span class="tparams">[<span name="A_">A_ &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="break">break: <a href="package$$Breakpoint.html" name="parsley.Breakpoint" id="parsley.Breakpoint" class="extype">Breakpoint</a> = <span class="symbol"><span class="name"><a href="package$$NoBreak$.html">NoBreak</a></span></span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.debug.A_" class="extype">A_</span>]</span></span><p class="shortcomment cmt">Using this method enables debugging functionality for this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Using this method enables debugging functionality for this parser. When it is entered a snapshot is taken and
presented on exit. It will signify when a parser is entered and exited as well. Use the break parameter to halt
execution on either entry, exit, both or neither.</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>The name to be assigned to this parser</p></dd><dt class="param">break</dt><dd class="cmt"><p>The breakpoint properties of this parser, defaults to NoBreak</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#filter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filter(pred:A=&gt;Boolean):parsley.Parsley[A]"></a><a id="filter((A)=&gt;Boolean):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#filter(pred:A=&gt;Boolean):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filter</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Filter the value of a parser; if the value returned by the parser matches the predicate <code>pred</code> then the
filter succeeded, otherwise the parser fails with an empty error</p><div class="fullcomment"><div class="comment cmt"><p>Filter the value of a parser; if the value returned by the parser matches the predicate <code>pred</code> then the
filter succeeded, otherwise the parser fails with an empty error</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>The predicate that is tested against the parser result</p></dd><dt>returns</dt><dd class="cmt"><p>The result of the invokee if it passes the predicate</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[B](f:A=&gt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="flatMap[B]((A)=&gt;Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#flatMap[B](f:A=&gt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.flatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This is the traditional Monadic binding operator for parsers.</p><div class="fullcomment"><div class="comment cmt"><p>This is the traditional Monadic binding operator for parsers. When the invokee produces a value, the function
<code>f</code> is used to produce a new parser that continued the computation.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A function that produces the next parser</p></dd><dt>returns</dt><dd class="cmt"><p>The parser produces from the application of <code>f</code> on the result of the last parser</p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p>There is significant overhead for using flatMap; if possible try to write parsers in an applicative
style otherwise try and use the intrinsic parsers provided to replace the flatMap.</p></span></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#flatten" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flatten[B](implicitev:A&lt;:&lt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="flatten[B](&lt;:&lt;[A,Parsley[B]]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#flatten[B](implicitev:A&lt;:&lt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>, <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.flatten.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>flatMap(identity)</code>.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#foldLeft" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldLeft[B](k:B)(f:(B,A)=&gt;B):parsley.Parsley[B]"></a><a id="foldLeft[B](B)((B,A)=&gt;B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#foldLeft[B](k:B)(f:(B,A)=&gt;B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldLeft</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="k">k: <span name="parsley.Parsley.LazyParsley.foldLeft.B" class="extype">B</span></span>)</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.foldLeft.B" class="extype">B</span>, <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="parsley.Parsley.LazyParsley.foldLeft.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.foldLeft.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">A fold for a parser: <code>p.foldLeft(k)(f)</code> will try executing <code>p</code> many times until it fails, combining the
results with left-associative application of <code>f</code> with a <code>k</code> on the left-most position
</p><div class="fullcomment"><div class="comment cmt"><p>A fold for a parser: <code>p.foldLeft(k)(f)</code> will try executing <code>p</code> many times until it fails, combining the
results with left-associative application of <code>f</code> with a <code>k</code> on the left-most position
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>base case for iteration</p></dd><dt class="param">f</dt><dd class="cmt"><p>combining function</p></dd><dt>returns</dt><dd class="cmt"><p>the result of folding the results of <code>p</code> with <code>f</code> and <code>k</code></p></dd></dl><dl class="attributes block"><div class="block">Example:<ol><li class="cmt"><p></p><pre><span class="kw">val</span> natural: Parsley[<span class="std">Int</span>] = digit.foldLeft(<span class="num">0</span>)((x, d) <span class="kw">=&gt;</span> x * <span class="num">10</span> + d.toInt)</pre></li></ol></div></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#foldRight" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldRight[B](k:B)(f:(A,B)=&gt;B):parsley.Parsley[B]"></a><a id="foldRight[B](B)((A,B)=&gt;B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#foldRight[B](k:B)(f:(A,B)=&gt;B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldRight</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="k">k: <span name="parsley.Parsley.LazyParsley.foldRight.B" class="extype">B</span></span>)</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>, <span name="parsley.Parsley.LazyParsley.foldRight.B" class="extype">B</span>) =&gt; <span name="parsley.Parsley.LazyParsley.foldRight.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.foldRight.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">A fold for a parser: <code>p.foldRight(k)(f)</code> will try executing <code>p</code> many times until it fails, combining the
results with right-associative application of <code>f</code> with a <code>k</code> at the right-most position
</p><div class="fullcomment"><div class="comment cmt"><p>A fold for a parser: <code>p.foldRight(k)(f)</code> will try executing <code>p</code> many times until it fails, combining the
results with right-associative application of <code>f</code> with a <code>k</code> at the right-most position
</p></div><dl class="paramcmts block"><dt class="param">k</dt><dd class="cmt"><p>base case for iteration</p></dd><dt class="param">f</dt><dd class="cmt"><p>combining function</p></dd><dt>returns</dt><dd class="cmt"><p>the result of folding the results of <code>p</code> with <code>f</code> and <code>k</code></p></dd></dl><dl class="attributes block"><div class="block">Example:<ol><li class="cmt"><p></p><pre>p.foldRight(Nil)(_::_) == many(p) <span class="cmt">//many is more efficient, however</span></pre></li></ol></div></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#getOrElse" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="getOrElse[B&gt;:A](x:B):parsley.Parsley[B]"></a><a id="getOrElse[B&gt;:A](B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#getOrElse[B&gt;:A](x:B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getOrElse</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="x">x: <span name="parsley.Parsley.LazyParsley.getOrElse.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.getOrElse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>&lt;/&gt;</code>.</p></li><li class="indented0 " name="parsley.Parsley.LazyParsley#guard" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guard(pred:A=&gt;Boolean,msggen:A=&gt;String):parsley.Parsley[A]"></a><a id="guard((A)=&gt;Boolean,(A)=&gt;String):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#guard(pred:A=&gt;Boolean,msggen:A=&gt;String):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guard</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msggen">msggen: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Similar to <code>filter</code>, except the error message desired is also provided.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>filter</code>, except the error message desired is also provided. This allows you to name the message
itself. The message is provided as a generator, which allows the user to avoid otherwise expensive
computation.</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>The predicate that is tested against the parser result</p></dd><dt class="param">msggen</dt><dd class="cmt"><p>Generator function for error message, generating a message based on the result of the parser</p></dd><dt>returns</dt><dd class="cmt"><p>The result of the invokee if it passes the predicate</p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#guard" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guard(pred:A=&gt;Boolean,msg:String):parsley.Parsley[A]"></a><a id="guard((A)=&gt;Boolean,String):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#guard(pred:A=&gt;Boolean,msg:String):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guard</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="msg">msg: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Similar to <code>filter</code>, except the error message desired is also provided.</p><div class="fullcomment"><div class="comment cmt"><p>Similar to <code>filter</code>, except the error message desired is also provided. This allows you to name the message
itself.</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>The predicate that is tested against the parser result</p></dd><dt class="param">msg</dt><dd class="cmt"><p>The message used for the error if the input failed the check</p></dd><dt>returns</dt><dd class="cmt"><p>The result of the invokee if it passes the predicate</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B):parsley.Parsley[B]"></a><a id="map[B]((A)=&gt;B):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#map[B](f:A=&gt;B):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="parsley.Parsley.LazyParsley.map.B" class="extype">B</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This is the functorial map operation for parsers.</p><div class="fullcomment"><div class="comment cmt"><p>This is the functorial map operation for parsers. When the invokee produces a value, this value is fed through
the function <code>f</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>The mutator to apply to the result of previous parse</p></dd><dt>returns</dt><dd class="cmt"><p>A new parser which parses the same input as the invokee but mutated by function <code>f</code></p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p>This is subject to aggressive optimisations assuming purity; the compiler is permitted to optimise such
that the application of <code>f</code> actually only happens once at compile time. In order to preserve the behaviour of
impure functions, consider using the <code>unsafe</code> method before map; <code>p.unsafe.map(f)</code>.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#orElse" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="orElse[B&gt;:A](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]"></a><a id="orElse[B&gt;:A](=&gt;Parsley[B]):Parsley[B]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#orElse[B&gt;:A](q:=&gt;parsley.Parsley[B]):parsley.Parsley[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">orElse</span><span class="tparams">[<span name="B">B &gt;: <span name="parsley.Parsley.LazyParsley.A" class="extype">A</span></span>]</span><span class="params">(<span name="q">q: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.orElse.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.orElse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">This combinator is an alias for <code>&lt;|&gt;</code>.</p></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#unary_+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unary_+:parsley.Parsley[A]"></a><a id="unary_+:Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#unary_+:parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: unary_$plus">unary_+</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Transforms this parser into a subroutine; instead of inlining this parser into every use-site (performing
optimisations and repeatedly generating code), produces a subroutine-like parser which is jumped to when
required.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms this parser into a subroutine; instead of inlining this parser into every use-site (performing
optimisations and repeatedly generating code), produces a subroutine-like parser which is jumped to when
required. This will introduce runtime overhead, but it is fairly cheap and speeds up the compilation
of parsers that are very big and used many times considerably.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The same parser, but wrapped in a subroutine call</p></dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#unexpected" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unexpected(msggen:A=&gt;String):parsley.Parsley[Nothing]"></a><a id="unexpected((A)=&gt;String):Parsley[Nothing]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#unexpected(msggen:A=&gt;String):parsley.Parsley[Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unexpected</span><span class="params">(<span name="msggen">msggen: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Nothing" class="extype">Nothing</span>]</span></span><p class="shortcomment cmt">Same as <code>unexpected</code>, except allows for a message generated from the result of the failed parser.</p><div class="fullcomment"><div class="comment cmt"><p>Same as <code>unexpected</code>, except allows for a message generated from the result of the failed parser. In essence,
this is equivalent to <code>p &gt;&gt;= (x =&gt; unexpected(x))</code> but requires no expensive computations from the use of
<code>&gt;&gt;=</code></p></div><dl class="paramcmts block"><dt class="param">msggen</dt><dd class="cmt"><p>The generator function for error message, creating a message based on the result of invokee</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that fails if it succeeds, with the given generator used to produce an unexpected message</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.Parsley.LazyParsley#withFilter" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="withFilter(pred:A=&gt;Boolean):parsley.Parsley[A]"></a><a id="withFilter((A)=&gt;Boolean):Parsley[A]"></a> <span class="permalink"><a href="../parsley/Parsley$$LazyParsley.html#withFilter(pred:A=&gt;Boolean):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withFilter</span><span class="params">(<span name="pred">pred: (<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.Parsley.LazyParsley.A" class="extype">A</span>]</span></span></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
