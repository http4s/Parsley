<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Parsley documentation  - parsley.TokenParser</title><meta content="Parsley documentation - parsley.TokenParser" name="description"/><meta content="Parsley documentation parsley.TokenParser" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript" src="../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title">Parsley documentation<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.parsley" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parsley"></a><a id="parsley:parsley"></a> <span class="permalink"><a href="index.html#parsley" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">parsley</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="parsley.instructions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="instructions"></a><a id="instructions:instructions"></a> <span class="permalink"><a href="../parsley/index.html#instructions" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instructions/index.html" title=""><span class="name">instructions</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="parsley" id="parsley" class="extype">parsley</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="BitGen$.html" title="This implementation uses a predicate to generate a BitSet." class="object"></a><a href="BitGen$.html" title="This implementation uses a predicate to generate a BitSet.">BitGen</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Breakpoint.html" title="" class="trait"></a><a href="package$$Breakpoint.html" title="">Breakpoint</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Char$.html" title="" class="object"></a><a href="Char$.html" title="">Char</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="CharSet$.html" title="This implementation uses a set of valid tokens." class="object"></a><a href="CharSet$.html" title="This implementation uses a set of valid tokens.">CharSet</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Combinator$.html" title="" class="object"></a><a href="Combinator$.html" title="">Combinator</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$EntryBreak$.html" title="" class="object"></a><a href="package$$EntryBreak$.html" title="">EntryBreak</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$ExitBreak$.html" title="" class="object"></a><a href="package$$ExitBreak$.html" title="">ExitBreak</a></li><li class="current-entities indented1"><a href="ExpressionParser$.html" title="" class="object"></a> <a href="ExpressionParser.html" title="This class is used to generate efficient expression parsers given a table of operators in operator of operator precedence and an atomic value that represents the smallest part of the expression." class="class"></a><a href="ExpressionParser.html" title="This class is used to generate efficient expression parsers given a table of operators in operator of operator precedence and an atomic value that represents the smallest part of the expression.">ExpressionParser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Failure.html" title="Returned on parsing failure" class="class"></a><a href="package$$Failure.html" title="Returned on parsing failure">Failure</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$FullBreak$.html" title="" class="object"></a><a href="package$$FullBreak$.html" title="">FullBreak</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Impl.html" title="The Impl trait is used to provide implementation of the parser requirements from LanguageDef" class="trait"></a><a href="Impl.html" title="The Impl trait is used to provide implementation of the parser requirements from LanguageDef">Impl</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Implicits$.html" title="Provides implicit conversions and lifts for different values and parsers." class="object"></a><a href="Implicits$.html" title="Provides implicit conversions and lifts for different values and parsers.">Implicits</a></li><li class="current-entities indented1"><a href="LanguageDef$.html" title="" class="object"></a> <a href="LanguageDef.html" title="This class is required to construct a TokenParser." class="class"></a><a href="LanguageDef.html" title="This class is required to construct a TokenParser.">LanguageDef</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$NoBreak$.html" title="" class="object"></a><a href="package$$NoBreak$.html" title="">NoBreak</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="NotRequired$.html" title="This implementation states that the required functionality is not required." class="object"></a><a href="NotRequired$.html" title="This implementation states that the required functionality is not required.">NotRequired</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Parser.html" title="The implementation provided is a parser which parses the required token." class="class"></a><a href="Parser.html" title="The implementation provided is a parser which parses the required token.">Parser</a></li><li class="current-entities indented1"><a href="Parsley$.html" title="" class="object"></a> <a href="Parsley.html" title="This is the class that encapsulates the act of parsing and running an object of this class with runParser will parse the string given as input to runParser." class="class"></a><a href="Parsley.html" title="This is the class that encapsulates the act of parsing and running an object of this class with runParser will parse the string given as input to runParser.">Parsley</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Predicate.html" title="The implementation provided is a function which matches on the input streams characters" class="class"></a><a href="Predicate.html" title="The implementation provided is a function which matches on the input streams characters">Predicate</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Result.html" title="Result of a parser." class="class"></a><a href="package$$Result.html" title="Result of a parser.">Result</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Success.html" title="Returned when a parser succeeded." class="class"></a><a href="package$$Success.html" title="Returned when a parser succeeded.">Success</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="" title="When provided with a LanguageDef, this class will produce a large variety of parsers that can be used for tokenisation of a language." class="class"></a><a href="" title="When provided with a LanguageDef, this class will produce a large variety of parsers that can be used for tokenisation of a language.">TokenParser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="package$$Var.html" title="This class is used to index registers within the mutable state." class="class"></a><a href="package$$Var.html" title="This class is used to index registers within the mutable state.">Var</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="index.html" name="parsley" id="parsley" class="extype">parsley</a></p><h1>TokenParser<span class="permalink"><a href="../parsley/TokenParser.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">TokenParser</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>When provided with a <code>LanguageDef</code>, this class will produce a large variety of parsers that can be used for
tokenisation of a language. This includes parsing numbers and strings in their various formats and ensuring that
all operations consume whitespace after them (so-called lexeme parsers). These are very useful in parsing
programming languages. This class also has a large number of hand-optimised intrinsic parsers to improve performance!</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="parsley.TokenParser"><span>TokenParser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="parsley.TokenParser#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(lang:parsley.LanguageDef):parsley.TokenParser"></a><a id="&lt;init&gt;:TokenParser"></a> <span class="permalink"><a href="../parsley/TokenParser.html#&lt;init&gt;(lang:parsley.LanguageDef):parsley.TokenParser" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">TokenParser</span><span class="params">(<span name="lang">lang: <a href="LanguageDef.html" name="parsley.LanguageDef" id="parsley.LanguageDef" class="extype">LanguageDef</a></span>)</span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">lang</dt><dd class="cmt"><p>The rules that govern the language we are tokenising</p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../parsley/TokenParser.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#angles" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="angles[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]"></a><a id="angles[A](=&gt;Parsley[A]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#angles[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">angles</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.angles.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.angles.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>angles(p)</code> parses <code>p</code> enclosed in angle brackets ('&lt;', '&gt;'), returning the
value of <code>p</code>.</p></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../parsley/TokenParser.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#braces" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="braces[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]"></a><a id="braces[A](=&gt;Parsley[A]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#braces[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">braces</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.braces.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.braces.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>braces(p)</code> parses <code>p</code> enclosed in braces ('{', '}'), returning the value of 'p'</p></li><li class="indented0 " name="parsley.TokenParser#brackets" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="brackets[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]"></a><a id="brackets[A](=&gt;Parsley[A]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#brackets[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">brackets</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.brackets.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.brackets.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>brackets(p)</code> parses <code>p</code> enclosed in brackets ('[', ']'), returning the value
of <code>p</code>.</p></li><li class="indented0 " name="parsley.TokenParser#charLiteral" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="charLiteral:parsley.Parsley[Char]"></a><a id="charLiteral:Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#charLiteral:parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">charLiteral</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a single literal character.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a single literal character. Returns the literal character value.
This parser deals correctly with escape sequences. The literal character is parsed according
to the grammar rules defined in the Haskell report (which matches most programming languages
quite closely).</p></div></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../parsley/TokenParser.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#colon" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="colon:parsley.Parsley[Char]"></a><a id="colon:Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#colon:parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">colon</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>colon</code> parses the character ':' and skips any trailing white space.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>colon</code> parses the character ':' and skips any trailing white space. Returns ":"</p></div></div></li><li class="indented0 " name="parsley.TokenParser#comma" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="comma:parsley.Parsley[Char]"></a><a id="comma:Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#comma:parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">comma</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>comma</code> parses the character ',' and skips any trailing white space.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>comma</code> parses the character ',' and skips any trailing white space. Returns ","</p></div></div></li><li class="indented0 " name="parsley.TokenParser#commaSep" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="commaSep[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]"></a><a id="commaSep[A](=&gt;Parsley[A]):Parsley[List[A]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#commaSep[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">commaSep</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.commaSep.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.TokenParser.commaSep.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Lexeme parser <code>commaSep(p)</code> parses zero or more occurrences of <code>p</code> separated by <code>comma</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>commaSep(p)</code> parses zero or more occurrences of <code>p</code> separated by <code>comma</code>.
Returns a list of values returned by <code>p</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#commaSep1" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="commaSep1[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]"></a><a id="commaSep1[A](=&gt;Parsley[A]):Parsley[List[A]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#commaSep1[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">commaSep1</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.commaSep1.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.TokenParser.commaSep1.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Lexeme parser <code>commaSep1(p)</code> parses one or more occurrences of <code>p</code> separated by <code>comma</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>commaSep1(p)</code> parses one or more occurrences of <code>p</code> separated by <code>comma</code>.
Returns a list of values returned by <code>p</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#decimal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="decimal:parsley.Parsley[Int]"></a><a id="decimal:Parsley[Int]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#decimal:parsley.Parsley[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">decimal</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">Parses a positive whole number in the decimal system.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a positive whole number in the decimal system. Returns the value of the number.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#dot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dot:parsley.Parsley[Char]"></a><a id="dot:Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#dot:parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">dot</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>dot</code> parses the character '.' and skips any trailing white space.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>dot</code> parses the character '.' and skips any trailing white space. Returns "."</p></div></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#float" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="float:parsley.Parsley[Double]"></a><a id="float:Parsley[Double]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#float:parsley.Parsley[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">float</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Double" class="extype">Double</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a floating point value.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a floating point value. Returns the value of the number. The number
is parsed according to the grammar rules defined in the Haskell report. Accepts an optional
'+' or '-' sign.</p></div></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../parsley/TokenParser.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#hexadecimal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hexadecimal:parsley.Parsley[Int]"></a><a id="hexadecimal:Parsley[Int]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#hexadecimal:parsley.Parsley[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">hexadecimal</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">Parses a positive whole number in the hexadecimal system.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a positive whole number in the hexadecimal system. The number should be prefixed with
"0x" or "0X". Returns the value of the number.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#identifier" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="identifier:parsley.Parsley[String]"></a><a id="identifier:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#identifier:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">identifier</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a legal identifier.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will
fail on identifiers that are reserved words (i.e. keywords). Legal identifier characters and
keywords are defined in the <code>LanguageDef</code> provided to the token parser. An identifier is treated
as a single token using <code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#integer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="integer:parsley.Parsley[Int]"></a><a id="integer:Parsley[Int]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#integer:parsley.Parsley[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">integer</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses an integer (a whole number).</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses an integer (a whole number). This parser is like <code>natural</code> except
that it can be prefixed with a sign (i.e '-' or '+'). Returns the value of the number. The
number can be specified in <code>decimal</code>, <code>hexadecimal</code> or <code>octal</code>. The number is parsed
according to the grammar rules in the haskell report.</p></div></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#keyword" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="keyword(name:String):parsley.Parsley[Unit]"></a><a id="keyword(String):Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#keyword(name:String):parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">keyword</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">The lexeme parser <code>keyword(name)</code> parses the symbol <code>name</code>, but it also checks that the <code>name</code>
is not a prefix of a valid identifier.</p><div class="fullcomment"><div class="comment cmt"><p>The lexeme parser <code>keyword(name)</code> parses the symbol <code>name</code>, but it also checks that the <code>name</code>
is not a prefix of a valid identifier. A <code>keyword</code> is treated as a single token using <code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#lexeme" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lexeme[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]"></a><a id="lexeme[A](=&gt;Parsley[A]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#lexeme[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lexeme</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.lexeme.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.lexeme.A" class="extype">A</span>]</span></span><p class="shortcomment cmt"><code>lexeme(p)</code> first applies parser <code>p</code> and then the <code>whiteSpace</code> parser, returning the value of
<code>p</code>.</p><div class="fullcomment"><div class="comment cmt"><p><code>lexeme(p)</code> first applies parser <code>p</code> and then the <code>whiteSpace</code> parser, returning the value of
<code>p</code>. Every lexical token (lexeme) is defined using <code>lexeme</code>, this way every parse starts at a
point without white space. The only point where the <code>whiteSpace</code> parser should be called
explicitly is the start of the main parser in order to skip any leading white space.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#maxOp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxOp(name:String):parsley.Parsley[Unit]"></a><a id="maxOp(String):Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#maxOp(name:String):parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxOp</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">The lexeme parser <code>maxOp(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not part of a larger reserved operator.</p><div class="fullcomment"><div class="comment cmt"><p>The lexeme parser <code>maxOp(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not part of a larger reserved operator. An <code>operator</code> is treated as a single token using
<code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#maxOp_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxOp_(name:String):parsley.Parsley[Unit]"></a><a id="maxOp_(String):Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#maxOp_(name:String):parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxOp_</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">The non-lexeme parser <code>maxOp_(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not part of a larger reserved operator.</p><div class="fullcomment"><div class="comment cmt"><p>The non-lexeme parser <code>maxOp_(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not part of a larger reserved operator. An <code>operator</code> is treated as a single token using
<code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#natural" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="natural:parsley.Parsley[Int]"></a><a id="natural:Parsley[Int]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#natural:parsley.Parsley[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">natural</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a natural number (a positive whole number).</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a natural number (a positive whole number). Returns the value of
the number. The number can specified in <code>decimal</code>, <code>hexadecimal</code> or <code>octal</code>. The number is
parsed according to the grammar rules in the Haskell report.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#naturalOrFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="naturalOrFloat:parsley.Parsley[Either[Int,Double]]"></a><a id="naturalOrFloat:Parsley[Either[Int,Double]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#naturalOrFloat:parsley.Parsley[Either[Int,Double]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">naturalOrFloat</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Either" class="extype">Either</span>[<span name="scala.Int" class="extype">Int</span>, <span name="scala.Double" class="extype">Double</span>]]</span></span><p class="shortcomment cmt">This lexeme parser parses either <code>natural</code> or <code>unsigned float</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses either <code>natural</code> or <code>unsigned float</code>. Returns the value of the number. This
parser deals with any overlap in the grammar rules for naturals and floats. The number is
parsed according to the grammar rules defined in the Haskell report.</p></div></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../parsley/TokenParser.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#number" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="number:parsley.Parsley[Either[Int,Double]]"></a><a id="number:Parsley[Either[Int,Double]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#number:parsley.Parsley[Either[Int,Double]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">number</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Either" class="extype">Either</span>[<span name="scala.Int" class="extype">Int</span>, <span name="scala.Double" class="extype">Double</span>]]</span></span><p class="shortcomment cmt">This lexeme parser parses either <code>integer</code> or <code>float</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses either <code>integer</code> or <code>float</code>. Returns the value of the number. This
parser deals with any overlap in the grammar rules for naturals and floats. The number is
parsed according to the grammar rules defined in the Haskell report.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#octal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="octal:parsley.Parsley[Int]"></a><a id="octal:Parsley[Int]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#octal:parsley.Parsley[Int]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">octal</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Int" class="extype">Int</span>]</span></span><p class="shortcomment cmt">Parses a positive whole number in the octal system.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a positive whole number in the octal system. The number should be prefixed with "0o"
or "0O". Returns the value of the number.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#operator" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="operator(name:String):parsley.Parsley[Unit]"></a><a id="operator(String):Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#operator(name:String):parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">operator</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">The lexeme parser <code>operator(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not the prefix of a valid operator.</p><div class="fullcomment"><div class="comment cmt"><p>The lexeme parser <code>operator(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not the prefix of a valid operator. An <code>operator</code> is treated as a single token using
<code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#operator_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="operator_(name:String):parsley.Parsley[Unit]"></a><a id="operator_(String):Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#operator_(name:String):parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">operator_</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">The non-lexeme parser <code>operator_(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not the prefix of a valid operator.</p><div class="fullcomment"><div class="comment cmt"><p>The non-lexeme parser <code>operator_(name)</code> parses the symbol <code>name</code>, but also checks that the <code>name</code>
is not the prefix of a valid operator. An <code>operator</code> is treated as a single token using
<code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#parens" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="parens[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]"></a><a id="parens[A](=&gt;Parsley[A]):Parsley[A]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#parens[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parens</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.parens.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.parens.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>parens(p)</code> parses <code>p</code> enclosed in parenthesis, returning the value of <code>p</code>.</p></li><li class="indented0 " name="parsley.TokenParser#rawStringLiteral" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rawStringLiteral:parsley.Parsley[String]"></a><a id="rawStringLiteral:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#rawStringLiteral:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">rawStringLiteral</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This non-lexeme parser parses a string in a raw fashion.</p><div class="fullcomment"><div class="comment cmt"><p>This non-lexeme parser parses a string in a raw fashion. The escape characters in the string
remain untouched. While escaped quotes do not end the string, they remain as \" in the result
instead of becoming a quote character. Does not support string gaps.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#reservedOp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reservedOp:parsley.Parsley[String]"></a><a id="reservedOp:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#reservedOp:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">reservedOp</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a reserved operator.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a reserved operator. Returns the name of the operator. Legal
operator characters and reserved operators are defined in the <code>LanguageDef</code> provided
to the token parser. A <code>reservedOp</code> is treated as a single token using <code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#reservedOp_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reservedOp_:parsley.Parsley[String]"></a><a id="reservedOp_:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#reservedOp_:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">reservedOp_</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This non-lexeme parser parses a reserved operator.</p><div class="fullcomment"><div class="comment cmt"><p>This non-lexeme parser parses a reserved operator. Returns the name of the operator.
Legal operator characters and reserved operators are defined in the <code>LanguageDef</code>
provided to the token parser. A <code>reservedOp_</code> is treated as a single token using <code>attempt</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#semi" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="semi:parsley.Parsley[Char]"></a><a id="semi:Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#semi:parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">semi</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>semi</code> parses the character ';' and skips any trailing white space.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>semi</code> parses the character ';' and skips any trailing white space. Returns ";"</p></div></div></li><li class="indented0 " name="parsley.TokenParser#semiSep" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="semiSep[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]"></a><a id="semiSep[A](=&gt;Parsley[A]):Parsley[List[A]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#semiSep[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">semiSep</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.semiSep.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.TokenParser.semiSep.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Lexeme parser <code>semiSep(p)</code> parses zero or more occurrences of <code>p</code> separated by <code>semi</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>semiSep(p)</code> parses zero or more occurrences of <code>p</code> separated by <code>semi</code>. Returns
a list of values returned by <code>p</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#semiSep1" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="semiSep1[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]"></a><a id="semiSep1[A](=&gt;Parsley[A]):Parsley[List[A]]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#semiSep1[A](p:=&gt;parsley.Parsley[A]):parsley.Parsley[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">semiSep1</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="p">p: =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="parsley.TokenParser.semiSep1.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.List" class="extype">List</span>[<span name="parsley.TokenParser.semiSep1.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Lexeme parser <code>semiSep1(p)</code> parses one or more occurrences of <code>p</code> separated by <code>semi</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lexeme parser <code>semiSep1(p)</code> parses one or more occurrences of <code>p</code> separated by <code>semi</code>. Returns
a list of values returned by <code>p</code>.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#skipComments" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="skipComments:parsley.Parsley[Unit]"></a><a id="skipComments:Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#skipComments:parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">skipComments</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Parses any comments and skips them, this includes both line comments and block comments.</p></li><li class="indented0 " name="parsley.TokenParser#stringLiteral" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stringLiteral:parsley.Parsley[String]"></a><a id="stringLiteral:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#stringLiteral:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">stringLiteral</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a literal string.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a literal string. Returns the literal string value. This parser
deals correctly with escape sequences and gaps. The literal string is parsed according to
the grammar rules defined in the Haskell report (which matches most programming languages
quite closely).</p></div></div></li><li class="indented0 " name="parsley.TokenParser#stringLiteral_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stringLiteral_:parsley.Parsley[String]"></a><a id="stringLiteral_:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#stringLiteral_:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">stringLiteral_</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This non-lexeme parser parses a literal string.</p><div class="fullcomment"><div class="comment cmt"><p>This non-lexeme parser parses a literal string. Returns the literal string value. This parser
deals correctly with escape sequences and gaps. The literal string is parsed according to
the grammar rules defined in the Haskell report (which matches most programming languages
quite closely).</p></div></div></li><li class="indented0 " name="parsley.TokenParser#symbol" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="symbol(name:Char):parsley.Parsley[Char]"></a><a id="symbol(scala.Char):Parsley[scala.Char]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#symbol(name:Char):parsley.Parsley[Char]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">symbol</span><span class="params">(<span name="name">name: <span name="scala.Char" class="extype">scala.Char</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Char" class="extype">scala.Char</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>symbol(c)</code> parses <code>char(c)</code> and skips trailing white space.</p></li><li class="indented0 " name="parsley.TokenParser#symbol" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="symbol(name:String):parsley.Parsley[String]"></a><a id="symbol(String):Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#symbol(name:String):parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">symbol</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">Lexeme parser <code>symbol(s)</code> parses <code>string(s)</code> and skips trailing white space.</p></li><li class="indented0 " name="parsley.TokenParser#symbol_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="symbol_(name:String):parsley.Parsley[String]"></a><a id="symbol_(String):Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#symbol_(name:String):parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">symbol_</span><span class="params">(<span name="name">name: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">Like <code>symbol</code>, but treats it as a single token using <code>attempt</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Like <code>symbol</code>, but treats it as a single token using <code>attempt</code>. Only useful for
strings, since characters are already single token.</p></div></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../parsley/TokenParser.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../parsley/TokenParser.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#unsignedFloat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsignedFloat:parsley.Parsley[Double]"></a><a id="unsignedFloat:Parsley[Double]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#unsignedFloat:parsley.Parsley[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">unsignedFloat</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Double" class="extype">Double</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a floating point value.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a floating point value. Returns the value of the number. The number
is parsed according to the grammar rules defined in the Haskell report.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#userOp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="userOp:parsley.Parsley[String]"></a><a id="userOp:Parsley[String]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#userOp:parsley.Parsley[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">userOp</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><p class="shortcomment cmt">This lexeme parser parses a legal operator.</p><div class="fullcomment"><div class="comment cmt"><p>This lexeme parser parses a legal operator. Returns the name of the operator. This parser
will fail on any operators that are reserved operators. Legal operator characters and
reserved operators are defined in the <code>LanguageDef</code> provided to the token parser. A
<code>userOp</code> is treated as a single token using <code>attempt</code>.</p></div></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../parsley/TokenParser.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="parsley.TokenParser#whiteSpace" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whiteSpace:parsley.Parsley[Unit]"></a><a id="whiteSpace:Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#whiteSpace:parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">whiteSpace</span><span class="result">: <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Parses any white space.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any white space. White space consists of zero or more occurrences of a <code>space</code> (as
provided by the <code>LanguageDef</code>), a line comment or a block (multi-line) comment. Block
comments may be nested. How comments are started and ended is defined in the <code>LanguageDef</code>
that is provided to the token parser.</p></div></div></li><li class="indented0 " name="parsley.TokenParser#whiteSpace_" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whiteSpace_:parsley.Impl=&gt;parsley.Parsley[Unit]"></a><a id="whiteSpace_:(Impl)=&gt;Parsley[Unit]"></a> <span class="permalink"><a href="../parsley/TokenParser.html#whiteSpace_:parsley.Impl=&gt;parsley.Parsley[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">whiteSpace_</span><span class="result">: (<a href="Impl.html" name="parsley.Impl" id="parsley.Impl" class="extype">Impl</a>) =&gt; <a href="Parsley.html" name="parsley.Parsley" id="parsley.Parsley" class="extype">Parsley</a>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Parses any white space.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any white space. White space consists of zero or more occurrences of a <code>space</code> (as
provided by the parameter), a line comment or a block (multi-line) comment. Block
comments may be nested. How comments are started and ended is defined in the <code>LanguageDef</code>
that is provided to the token parser.</p></div></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
